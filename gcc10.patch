diff -ur hydra-8.6/hydra-asterisk.c hydra-8.6-gcc10/hydra-asterisk.c
--- hydra-8.6/hydra-asterisk.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-asterisk.c	2021-10-17 23:50:04.727544648 +0200
@@ -9,7 +9,7 @@
 
 extern char *HYDRA_EXIT;
 
-char *buf;
+static char *buf;
 
 int32_t start_asterisk(int32_t s, char *ip, int32_t port, unsigned char options, char *miscptr, FILE * fp) {
   char *empty = "\"\"";
diff -ur hydra-8.6/hydra.c hydra-8.6-gcc10/hydra.c
--- hydra-8.6/hydra.c	2017-07-21 13:33:16.000000000 +0200
+++ hydra-8.6-gcc10/hydra.c	2021-10-17 23:50:04.727544648 +0200
@@ -352,19 +352,19 @@
 #if !defined(ANDROID) && !defined(__BIONIC__)
 extern int32_t errno;
 #endif
-extern int32_t debug;
-extern int32_t verbose;
-extern int32_t waittime;
-extern int32_t port;
-extern int32_t found;
-extern int32_t use_proxy;
-extern int32_t proxy_count;
-extern int32_t selected_proxy;
-extern int32_t proxy_string_port[MAX_PROXY_COUNT];
-extern char proxy_string_ip[MAX_PROXY_COUNT][36];
-extern char proxy_string_type[MAX_PROXY_COUNT][10];
-extern char *proxy_authentication[MAX_PROXY_COUNT];
-extern char *cmdlinetarget;
+int32_t debug;
+int32_t verbose;
+int32_t waittime;
+int32_t port;
+int32_t found;
+int32_t use_proxy;
+int32_t proxy_count;
+int32_t selected_proxy;
+int32_t proxy_string_port[MAX_PROXY_COUNT];
+char proxy_string_ip[MAX_PROXY_COUNT][36];
+char proxy_string_type[MAX_PROXY_COUNT][10];
+char *proxy_authentication[MAX_PROXY_COUNT];
+char *cmdlinetarget;
 extern char *fe80;
 
 // required global vars
diff -ur hydra-8.6/hydra-cisco.c hydra-8.6-gcc10/hydra-cisco.c
--- hydra-8.6/hydra-cisco.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-cisco.c	2021-10-17 23:50:04.727544648 +0200
@@ -5,11 +5,11 @@
 #endif
 
 extern char *HYDRA_EXIT;
-char *buf = NULL;
 
 int32_t start_cisco(int32_t s, char *ip, int32_t port, unsigned char options, char *miscptr, FILE * fp) {
   char *empty = "";
   char *pass, buffer[300];
+  char *buf = NULL;
 
   if (strlen(pass = hydra_get_next_password()) == 0)
     pass = empty;
diff -ur hydra-8.6/hydra-cisco-enable.c hydra-8.6-gcc10/hydra-cisco-enable.c
--- hydra-8.6/hydra-cisco-enable.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-cisco-enable.c	2021-10-17 23:50:04.727544648 +0200
@@ -1,11 +1,11 @@
 #include "hydra-mod.h"
 
 extern char *HYDRA_EXIT;
-char *buf;
 
 int32_t start_cisco_enable(int32_t s, char *ip, int32_t port, unsigned char options, char *miscptr, FILE * fp) {
   char *empty = "";
   char *pass, buffer[300];
+  char *buf;
 
   if (strlen(pass = hydra_get_next_password()) == 0)
     pass = empty;
@@ -63,6 +63,7 @@
   int32_t myport = PORT_TELNET, mysslport = PORT_TELNET_SSL;
   char buffer[300];
   char *login;
+  char *buf;
 
   hydra_register_socket(sp);
   if (memcmp(hydra_get_next_pair(), &HYDRA_EXIT, sizeof(HYDRA_EXIT)) == 0)
diff -ur hydra-8.6/hydra-cvs.c hydra-8.6-gcc10/hydra-cvs.c
--- hydra-8.6/hydra-cvs.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-cvs.c	2021-10-17 23:50:04.727544648 +0200
@@ -3,13 +3,13 @@
 extern int32_t hydra_data_ready_timed(int32_t socket, long sec, long usec);
 
 extern char *HYDRA_EXIT;
-char *buf;
 
 int32_t start_cvs(int32_t s, char *ip, int32_t port, unsigned char options, char *miscptr, FILE * fp) {
   char *empty = "";
   char *login, *pass, buffer[1024], pass2[513];
   int32_t i;
   char *directory = miscptr;
+  char *buf;
 
 /* evil cvs encryption sheme... 
         0 111           P 125           p  58
diff -ur hydra-8.6/hydra-ftp.c hydra-8.6-gcc10/hydra-ftp.c
--- hydra-8.6/hydra-ftp.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-ftp.c	2021-10-17 23:50:04.727544648 +0200
@@ -1,11 +1,11 @@
 #include "hydra-mod.h"
 
 extern char *HYDRA_EXIT;
-char *buf;
 
 int32_t start_ftp(int32_t s, char *ip, int32_t port, unsigned char options, char *miscptr, FILE * fp) {
   char *empty = "\"\"";
   char *login, *pass, buffer[510];
+  char *buf;
 
   if (strlen(login = hydra_get_next_login()) == 0)
     login = empty;
@@ -77,6 +77,7 @@
 void service_ftp_core(char *ip, int32_t sp, unsigned char options, char *miscptr, FILE * fp, int32_t port, char *hostname, int32_t tls) {
   int32_t run = 1, next_run = 1, sock = -1;
   int32_t myport = PORT_FTP, mysslport = PORT_FTP_SSL;
+  char *buf;
 
   hydra_register_socket(sp);
   if (memcmp(hydra_get_next_pair(), &HYDRA_EXIT, sizeof(HYDRA_EXIT)) == 0)
diff -ur hydra-8.6/hydra-gtk/src/main.c hydra-8.6-gcc10/hydra-gtk/src/main.c
--- hydra-8.6/hydra-gtk/src/main.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-gtk/src/main.c	2021-10-17 23:50:04.727544648 +0200
@@ -18,11 +18,12 @@
 char *hydra_path2 = "/usr/local/bin/hydra";
 char *hydra_path3 = "/usr/bin/hydra";
 
+GtkWidget *wndMain;
+char *HYDRA_BIN;
+guint message_id;
 
 int main(int argc, char *argv[]) {
-  extern GtkWidget *wndMain;
   int i;
-  extern guint message_id;
   GtkWidget *output;
   GtkTextBuffer *outputbuf;
 
diff -ur hydra-8.6/hydra-gtk/src/support.h hydra-8.6-gcc10/hydra-gtk/src/support.h
--- hydra-8.6/hydra-gtk/src/support.h	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-gtk/src/support.h	2021-10-17 23:50:04.727544648 +0200
@@ -40,6 +40,6 @@
 void glade_set_atk_action_description(AtkAction * action, const gchar * action_name, const gchar * description);
 
 
-GtkWidget *wndMain;
-char *HYDRA_BIN;
-guint message_id;
+extern GtkWidget *wndMain;
+extern char *HYDRA_BIN;
+extern guint message_id;
diff -ur hydra-8.6/hydra-http-form.c hydra-8.6-gcc10/hydra-http-form.c
--- hydra-8.6/hydra-http-form.c	2017-07-21 13:31:14.000000000 +0200
+++ hydra-8.6-gcc10/hydra-http-form.c	2021-10-17 23:50:04.730877987 +0200
@@ -58,7 +58,7 @@
 #define HEADER_TYPE_DEFAULT_REPL                'd'
 
 extern char *HYDRA_EXIT;
-char *buf;
+static char *buf;
 char *cond;
 
 typedef struct header_node {
@@ -83,7 +83,7 @@
 
 extern char *webtarget;
 extern char *slash;
-int32_t webport, freemischttpform = 0;
+int32_t form_webport, freemischttpform = 0;
 char bufferurl[6096+24], cookieurl[6096+24] = "", userheader[6096+24] = "", *url, *variables, *optional1;
 
 #define MAX_REDIRECT 				8
@@ -616,7 +616,7 @@
   if (use_proxy == 1 && proxy_authentication[selected_proxy] != NULL) {
     if (getcookie) {
       memset(proxy_string, 0, sizeof(proxy_string));
-      snprintf(proxy_string, MAX_PROXY_LENGTH - 1, "http://%s:%d%.600s", webtarget, webport, cookieurl);
+      snprintf(proxy_string, MAX_PROXY_LENGTH - 1, "http://%s:%d%.600s", webtarget, form_webport, cookieurl);
       http_request = prepare_http_request("GET", proxy_string, NULL, cookie_request);
       if (hydra_send(s, http_request, strlen(http_request), 0) < 0)
         return 1;
@@ -628,7 +628,7 @@
     // now prepare for the "real" request
     if (strcmp(type, "POST") == 0) {
       memset(proxy_string, 0, sizeof(proxy_string));
-      snprintf(proxy_string, MAX_PROXY_LENGTH - 1, "http://%s:%d%.600s", webtarget, webport, url);
+      snprintf(proxy_string, MAX_PROXY_LENGTH - 1, "http://%s:%d%.600s", webtarget, form_webport, url);
       snprintf(content_length, MAX_CONTENT_LENGTH - 1, "%d", (int32_t) strlen(upd3variables));
       if (header_exists(&ptr_head, "Content-Length", HEADER_TYPE_DEFAULT))
         hdrrepv(&ptr_head, "Content-Length", content_length);
@@ -664,7 +664,7 @@
       if (getcookie) {
         //doing a GET to get cookies
         memset(proxy_string, 0, sizeof(proxy_string));
-        snprintf(proxy_string, MAX_PROXY_LENGTH - 1, "http://%s:%d%.600s", webtarget, webport, cookieurl);
+        snprintf(proxy_string, MAX_PROXY_LENGTH - 1, "http://%s:%d%.600s", webtarget, form_webport, cookieurl);
         http_request = prepare_http_request("GET", proxy_string, NULL, cookie_request);
         if (hydra_send(s, http_request, strlen(http_request), 0) < 0)
           return 1;
@@ -676,7 +676,7 @@
       // now prepare for the "real" request
       if (strcmp(type, "POST") == 0) {
         memset(proxy_string, 0, sizeof(proxy_string));
-        snprintf(proxy_string, MAX_PROXY_LENGTH - 1, "http://%s:%d%.600s", webtarget, webport, url);
+        snprintf(proxy_string, MAX_PROXY_LENGTH - 1, "http://%s:%d%.600s", webtarget, form_webport, url);
         snprintf(content_length, MAX_CONTENT_LENGTH - 1, "%d", (int32_t) strlen(upd3variables));
         if (header_exists(&ptr_head, "Content-Length", HEADER_TYPE_DEFAULT))
           hdrrepv(&ptr_head, "Content-Length", content_length);
@@ -863,7 +863,7 @@
         // proxy with authentication
         hdrrepv(&ptr_head, "Host", str2);
         memset(proxy_string, 0, sizeof(proxy_string));
-        snprintf(proxy_string, MAX_PROXY_LENGTH - 1, "http://%s:%d%.600s", webtarget, webport, str3);
+        snprintf(proxy_string, MAX_PROXY_LENGTH - 1, "http://%s:%d%.600s", webtarget, form_webport, str3);
         normal_request = stringify_headers(&ptr_head);
         http_request = prepare_http_request("GET", proxy_string, NULL, normal_request);
       } else {
@@ -871,7 +871,7 @@
           // proxy without authentication
           hdrrepv(&ptr_head, "Host", str2);
           memset(proxy_string, 0, sizeof(proxy_string));
-          snprintf(proxy_string, MAX_PROXY_LENGTH - 1, "http://%s:%d%.600s", webtarget, webport, str3);
+          snprintf(proxy_string, MAX_PROXY_LENGTH - 1, "http://%s:%d%.600s", webtarget, form_webport, str3);
           normal_request = stringify_headers(&ptr_head);
           http_request = prepare_http_request("GET", proxy_string, NULL, normal_request);
         } else {
@@ -1056,11 +1056,11 @@
   else if (webtarget == NULL && cmdlinetarget == NULL)
     webtarget = hydra_address2string(ip);
   if (port != 0)
-    webport = port;
+    form_webport = port;
   else if ((options & OPTION_SSL) == 0)
-    webport = PORT_HTTP;
+    form_webport = PORT_HTTP;
   else
-    webport = PORT_HTTP_SSL;
+    form_webport = PORT_HTTP_SSL;
 
   sprintf(bufferurl, "%.6096s", miscptr);
   url = bufferurl;
diff -ur hydra-8.6/hydra-http-proxy-urlenum.c hydra-8.6-gcc10/hydra-http-proxy-urlenum.c
--- hydra-8.6/hydra-http-proxy-urlenum.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-http-proxy-urlenum.c	2021-10-17 23:50:04.727544648 +0200
@@ -2,7 +2,6 @@
 #include "sasl.h"
 
 extern char *HYDRA_EXIT;
-char *buf;
 static int32_t http_proxy_auth_mechanism = AUTH_ERROR;
 
 int32_t start_http_proxy_urlenum(int32_t s, char *ip, int32_t port, unsigned char options, char *miscptr, FILE * fp, char *hostname) {
@@ -12,6 +11,7 @@
   char *header = "";            /* XXX TODO */
   char *ptr;
   int32_t auth = 0;
+  char *buf;
 
   login = hydra_get_next_login();
   if (login == NULL || strlen(login) == 0 || strstr(login, "://") == NULL) {
diff -ur hydra-8.6/hydra-imap.c hydra-8.6-gcc10/hydra-imap.c
--- hydra-8.6/hydra-imap.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-imap.c	2021-10-17 23:50:04.730877987 +0200
@@ -2,8 +2,7 @@
 #include "sasl.h"
 
 extern char *HYDRA_EXIT;
-char *buf;
-int32_t counter;
+int32_t imap_counter;
 
 int32_t imap_auth_mechanism = AUTH_CLEAR;
 
@@ -42,6 +41,7 @@
 int32_t start_imap(int32_t s, char *ip, int32_t port, unsigned char options, char *miscptr, FILE * fp) {
   char *empty = "";
   char *login, *pass, buffer[500], buffer2[500], *fooptr;
+  char *buf;
 
   if (strlen(login = hydra_get_next_login()) == 0)
     login = empty;
@@ -56,7 +56,7 @@
 
   switch (imap_auth_mechanism) {
   case AUTH_LOGIN:
-    sprintf(buffer, "%d AUTHENTICATE LOGIN\r\n", counter);
+    sprintf(buffer, "%d AUTHENTICATE LOGIN\r\n", imap_counter);
     if (hydra_send(s, buffer, strlen(buffer), 0) < 0) {
       return 1;
     }
@@ -89,7 +89,7 @@
     break;
 
   case AUTH_PLAIN:
-    sprintf(buffer, "%d AUTHENTICATE PLAIN\r\n", counter);
+    sprintf(buffer, "%d AUTHENTICATE PLAIN\r\n", imap_counter);
     if (hydra_send(s, buffer, strlen(buffer), 0) < 0) {
       return 1;
     }
@@ -122,13 +122,13 @@
       switch (imap_auth_mechanism) {
 
       case AUTH_CRAMMD5:
-        sprintf(buffer, "%d AUTHENTICATE CRAM-MD5\r\n", counter);
+        sprintf(buffer, "%d AUTHENTICATE CRAM-MD5\r\n", imap_counter);
         break;
       case AUTH_CRAMSHA1:
-        sprintf(buffer, "%d AUTHENTICATE CRAM-SHA1\r\n", counter);
+        sprintf(buffer, "%d AUTHENTICATE CRAM-SHA1\r\n", imap_counter);
         break;
       case AUTH_CRAMSHA256:
-        sprintf(buffer, "%d AUTHENTICATE CRAM-SHA256\r\n", counter);
+        sprintf(buffer, "%d AUTHENTICATE CRAM-SHA256\r\n", imap_counter);
         break;
       }
       if (hydra_send(s, buffer, strlen(buffer), 0) < 0) {
@@ -186,7 +186,7 @@
     }
     break;
   case AUTH_DIGESTMD5:{
-      sprintf(buffer, "%d AUTHENTICATE DIGEST-MD5\r\n", counter);
+      sprintf(buffer, "%d AUTHENTICATE DIGEST-MD5\r\n", imap_counter);
 
       if (hydra_send(s, buffer, strlen(buffer), 0) < 0)
         return 1;
@@ -225,7 +225,7 @@
       if (rc) {
         return 3;
       }
-      sprintf(buffer, "%d AUTHENTICATE SCRAM-SHA-1\r\n", counter);
+      sprintf(buffer, "%d AUTHENTICATE SCRAM-SHA-1\r\n", imap_counter);
       if (hydra_send(s, buffer, strlen(buffer), 0) < 0) {
         return 1;
       }
@@ -283,7 +283,7 @@
       unsigned char buf2[4096];
 
       //Send auth request
-      sprintf(buffer, "%d AUTHENTICATE NTLM\r\n", counter);
+      sprintf(buffer, "%d AUTHENTICATE NTLM\r\n", imap_counter);
 
       if (hydra_send(s, buffer, strlen(buffer), 0) < 0)
         return 1;
@@ -324,7 +324,7 @@
     break;
   default:
     //clear authentication
-    sprintf(buffer, "%d LOGIN \"%.100s\" \"%.100s\"\r\n", counter, login, pass);
+    sprintf(buffer, "%d LOGIN \"%.100s\" \"%.100s\"\r\n", imap_counter, login, pass);
   }
 
   if (hydra_send(s, buffer, strlen(buffer), 0) < 0) {
@@ -340,7 +340,7 @@
     hydra_completed_pair();
     if (memcmp(hydra_get_next_pair(), &HYDRA_EXIT, sizeof(HYDRA_EXIT)) == 0)
       return 3;
-    if (counter == 4)
+    if (imap_counter == 4)
       return 1;
     return (2);
   }
@@ -357,6 +357,7 @@
   int32_t run = 1, next_run = 1, sock = -1;
   int32_t myport = PORT_IMAP, mysslport = PORT_IMAP_SSL, disable_tls = 1;
   char *buffer1 = "1 CAPABILITY\r\n";
+  char *buf;
 
   hydra_register_socket(sp);
   if (memcmp(hydra_get_next_pair(), &HYDRA_EXIT, sizeof(HYDRA_EXIT)) == 0)
@@ -396,7 +397,7 @@
       /* send capability request */
       if (hydra_send(sock, buffer1, strlen(buffer1), 0) < 0)
         exit(-1);
-      counter = 2;
+      imap_counter = 2;
       buf = imap_read_server_capacity(sock);
 
       if (buf == NULL) {
@@ -418,7 +419,7 @@
         /* check for STARTTLS, if available we may have access to more basic auth methods */
         if (strstr(buf, "STARTTLS") != NULL) {
           hydra_send(sock, "2 STARTTLS\r\n", strlen("2 STARTTLS\r\n"), 0);
-          counter++;
+          imap_counter++;
           free(buf);
           buf = hydra_receive_line(sock);
           if (buf == NULL || (strstr(buf, " NO ") != NULL || strstr(buf, "failed") != NULL || strstr(buf, " BAD ") != NULL)) {
@@ -439,7 +440,7 @@
             if (hydra_send(sock, "3 CAPABILITY\r\n", strlen("3 CAPABILITY\r\n"), 0) < 0)
               hydra_child_exit(2);
             buf = imap_read_server_capacity(sock);
-            counter++;
+            imap_counter++;
             if (buf == NULL)
               hydra_child_exit(2);
           }
@@ -556,7 +557,7 @@
       break;
     case 2:                    /* run the cracking function */
       next_run = start_imap(sock, ip, port, options, miscptr, fp);
-      counter++;
+      imap_counter++;
       break;
     case 3:                    /* clean exit */
       if (sock >= 0)
diff -ur hydra-8.6/hydra-irc.c hydra-8.6-gcc10/hydra-irc.c
--- hydra-8.6/hydra-irc.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-irc.c	2021-10-17 23:50:04.727544648 +0200
@@ -7,7 +7,6 @@
 */
 
 extern char *HYDRA_EXIT;
-char *buf;
 char buffer[300] = "";
 int32_t myport = PORT_IRC, mysslport = PORT_IRC_SSL;
 
diff -ur hydra-8.6/hydra-ldap.c hydra-8.6-gcc10/hydra-ldap.c
--- hydra-8.6/hydra-ldap.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-ldap.c	2021-10-17 23:50:04.730877987 +0200
@@ -3,8 +3,7 @@
 
 extern char *HYDRA_EXIT;
 
-unsigned char *buf;
-int32_t counter;
+int32_t ldap_counter;
 int32_t tls_required = 0;
 
 int32_t start_ldap(int32_t s, char *ip, int32_t port, unsigned char options, char *miscptr, FILE * fp, char *hostname, char version, int32_t auth_method) {
@@ -13,6 +12,7 @@
   unsigned char buffer[512];
   int32_t length = 0;
   int32_t ldap_auth_mechanism = auth_method;
+  unsigned char *buf;
 
   /*
      The LDAP "simple" method has three modes of operation:
@@ -53,7 +53,7 @@
 
   buffer[2] = 2;
   buffer[3] = 1;
-  buffer[4] = counter % 256;
+  buffer[4] = ldap_counter % 256;
 
   buffer[5] = 96;
   buffer[6] = length - 7;
@@ -126,7 +126,7 @@
     sasl_cram_md5(fooptr, pass, ptr);
     if (fooptr == NULL)
       return 1;
-    counter++;
+    ldap_counter++;
     if (strstr(miscptr, "^USER^") != NULL) {
       miscptr = hydra_strrep(miscptr, "^USER^", login);
     }
@@ -139,7 +139,7 @@
 
     buffer[2] = 2;
     buffer[3] = 1;
-    buffer[4] = counter % 256;
+    buffer[4] = ldap_counter % 256;
 
     buffer[5] = 96;
     buffer[6] = length - 7;
@@ -174,7 +174,7 @@
 
       ptr = strstr((char *) buf, "realm=");
 
-      counter++;
+      ldap_counter++;
       if (strstr(miscptr, "^USER^") != NULL) {
         miscptr = hydra_strrep(miscptr, "^USER^", login);
       }
@@ -211,7 +211,7 @@
       ind++;
       buffer[ind] = 1;
       ind++;
-      buffer[ind] = counter % 256;
+      buffer[ind] = ldap_counter % 256;
       ind++;
       buffer[ind] = 96;         /*0x60 */
       ind++;
@@ -354,6 +354,7 @@
 void service_ldap(char *ip, int32_t sp, unsigned char options, char *miscptr, FILE * fp, int32_t port, char *hostname, char version, int32_t auth_method) {
   int32_t run = 1, next_run = 1, sock = -1;
   int32_t myport = PORT_LDAP, mysslport = PORT_LDAP_SSL;
+  unsigned char *buf;
 
   hydra_register_socket(sp);
   if (memcmp(hydra_get_next_pair(), &HYDRA_EXIT, sizeof(HYDRA_EXIT)) == 0)
@@ -380,7 +381,7 @@
           hydra_report(stderr, "[ERROR] Child with pid %d terminating, can not connect\n", (int32_t) getpid());
         hydra_child_exit(1);
       }
-      counter = 1;
+      ldap_counter = 1;
       if (tls_required) {
         /* Start TLS operation OID = 1.3.6.1.4.1.1466.20037 according to RFC 2830 */
         char confidentiality_required[] = "\x30\x1d\x02\x01\x01\x77\x18\x80\x16\x31\x2e\x33\x2e\x36\x2e\x31\x2e\x34\x2e\x31\x2e\x31\x34\x36\x36\x2e\x32\x30\x30\x33\x37";
@@ -399,7 +400,7 @@
           } else {
             if (verbose)
               hydra_report(stderr, "[VERBOSE] TLS connection done\n");
-            counter++;
+            ldap_counter++;
           }
         } else {
           hydra_report(stderr, "[ERROR] Can't use TLS %s\n", buf);
@@ -410,7 +411,7 @@
       break;
     case 2:                    /* run the cracking function */
       next_run = start_ldap(sock, ip, port, options, miscptr, fp, hostname, version, auth_method);
-      counter++;
+      ldap_counter++;
       break;
     case 3:                    /* clean exit */
       if (sock >= 0)
diff -ur hydra-8.6/hydra-mod.c hydra-8.6-gcc10/hydra-mod.c
--- hydra-8.6/hydra-mod.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-mod.c	2021-10-17 23:50:04.727544648 +0200
@@ -463,7 +463,7 @@
   BIGNUM *n;
   n = BN_new();
   RSA_get0_key(rsa, &n, NULL, NULL);
-  ok = BN_zero(n);
+  BN_zero(n);
 #else
   if (rsa->n == 0)
     ok = 1;
diff -ur hydra-8.6/hydra-mod.h hydra-8.6-gcc10/hydra-mod.h
--- hydra-8.6/hydra-mod.h	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-mod.h	2021-10-17 23:50:04.727544648 +0200
@@ -45,19 +45,19 @@
 #endif
 char *hydra_string_replace(const char *string, const char *substr, const char *replacement);
 
-int32_t debug;
-int32_t verbose;
-int32_t waittime;
-int32_t port;
-int32_t found;
-int32_t proxy_count;
-int32_t use_proxy;
-int32_t selected_proxy;
-char proxy_string_ip[MAX_PROXY_COUNT][36];
-int32_t proxy_string_port[MAX_PROXY_COUNT];
-char proxy_string_type[MAX_PROXY_COUNT][10];
-char *proxy_authentication[MAX_PROXY_COUNT];
-char *cmdlinetarget;
+extern int32_t debug;
+extern int32_t verbose;
+extern int32_t waittime;
+extern int32_t port;
+extern int32_t found;
+extern int32_t proxy_count;
+extern int32_t use_proxy;
+extern int32_t selected_proxy;
+extern char proxy_string_ip[MAX_PROXY_COUNT][36];
+extern int32_t proxy_string_port[MAX_PROXY_COUNT];
+extern char proxy_string_type[MAX_PROXY_COUNT][10];
+extern char *proxy_authentication[MAX_PROXY_COUNT];
+extern char *cmdlinetarget;
 
 typedef int32_t BOOL;
 
diff -ur hydra-8.6/hydra-mssql.c hydra-8.6-gcc10/hydra-mssql.c
--- hydra-8.6/hydra-mssql.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-mssql.c	2021-10-17 23:50:04.727544648 +0200
@@ -3,7 +3,6 @@
 #define MSLEN 30
 
 extern char *HYDRA_EXIT;
-char *buf;
 
 unsigned char p_hdr[] =
   "\x02\x00\x02\x00\x00\x00\x02\x00\x00\x00" "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" "\x00\x00\x00\x00\x00\x00\x00\x00\x00";
@@ -93,13 +92,11 @@
   if (ret > 10 && buffer[8] == '\xe3') {
     hydra_report_found_host(port, ip, "mssql", fp);
     hydra_completed_pair_found();
-    free(buf);
     if (memcmp(hydra_get_next_pair(), &HYDRA_EXIT, sizeof(HYDRA_EXIT)) == 0)
       return 2;
     return 1;
   }
 
-  free(buf);
   hydra_completed_pair();
   if (memcmp(hydra_get_next_pair(), &HYDRA_EXIT, sizeof(HYDRA_EXIT)) == 0)
     return 2;
diff -ur hydra-8.6/hydra-nntp.c hydra-8.6-gcc10/hydra-nntp.c
--- hydra-8.6/hydra-nntp.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-nntp.c	2021-10-17 23:50:04.727544648 +0200
@@ -13,7 +13,6 @@
 int32_t nntp_auth_mechanism = AUTH_CLEAR;
 
 extern char *HYDRA_EXIT;
-char *buf;
 
 char *nntp_read_server_capacity(int32_t sock) {
   char *ptr = NULL;
@@ -51,6 +50,7 @@
   char *empty = "\"\"";
   char *login, *pass, buffer[500], buffer2[500], *fooptr;
   int32_t i = 1;
+  char *buf;
 
   if (strlen(login = hydra_get_next_login()) == 0)
     login = empty;
@@ -270,6 +270,7 @@
   int32_t i = 0, run = 1, next_run = 1, sock = -1;
   int32_t myport = PORT_NNTP, mysslport = PORT_NNTP_SSL, disable_tls = 0;
   char *buffer1 = "CAPABILITIES\r\n";
+  char *buf;
 
   hydra_register_socket(sp);
   if (memcmp(hydra_get_next_pair(), &HYDRA_EXIT, sizeof(HYDRA_EXIT)) == 0)
diff -ur hydra-8.6/hydra-oracle-listener.c hydra-8.6-gcc10/hydra-oracle-listener.c
--- hydra-8.6/hydra-oracle-listener.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-oracle-listener.c	2021-10-17 23:50:04.730877987 +0200
@@ -22,8 +22,7 @@
 #define HASHSIZE 17
 
 extern char *HYDRA_EXIT;
-char *buf;
-unsigned char *hash;
+unsigned char *ora_hash_pass;
 int32_t sid_mechanism = AUTH_PLAIN;
 
 int32_t initial_permutation(unsigned char **result, char *p_str, int32_t *sz) {
@@ -138,7 +137,7 @@
 }
 
 int32_t ora_hash_password(char *pass) {
-  // secret hash function comes here, and written to char *hash
+  // secret hash function comes here, and written to char *ora_hash_pass
   int32_t siz = 0;
   unsigned char *desresult;
   unsigned char *result;
@@ -172,7 +171,7 @@
     return 1;
   }
 
-  memcpy(hash, result, HASHSIZE);
+  memcpy(ora_hash_pass, result, HASHSIZE);
   free(desresult);
   free(result);
 
@@ -192,6 +191,7 @@
   char connect_string[200];
   char buffer2[260];
   int32_t siz = 0;
+  char *buf;
 
   memset(connect_string, 0, sizeof(connect_string));
   memset(buffer2, 0, sizeof(buffer2));
@@ -200,22 +200,22 @@
     pass = empty;
 
   if (sid_mechanism == AUTH_PLAIN) {
-    if ((hash = malloc(HASHSIZE)) == NULL) {
+    if ((ora_hash_pass = malloc(HASHSIZE)) == NULL) {
       hydra_report(stderr, "[ERROR] Can't allocate memory\n");
       return 1;
     }
-    memset(hash, 0, HASHSIZE);
+    memset(ora_hash_pass, 0, HASHSIZE);
     if (ora_hash_password(pass)) {
       hydra_report(stderr, "[ERROR] generating Oracle hash\n");
-      free(hash);
+      free(ora_hash_pass);
       return 1;
     }
-    pass = (char *) hash;
+    pass = (char *) ora_hash_pass;
   }
   snprintf(connect_string, sizeof(connect_string), "(DESCRIPTION=(CONNECT_DATA=(CID=(PROGRAM=))(COMMAND=reload)(PASSWORD=%s)(SERVICE=)(VERSION=169869568)))", pass);
 
-  if (hash != NULL)
-    free(hash);
+  if (ora_hash_pass != NULL)
+    free(ora_hash_pass);
   if (verbose)
     hydra_report(stderr, "[VERBOSE] using connectiong string: %s\n", connect_string);
 
diff -ur hydra-8.6/hydra-oracle-sid.c hydra-8.6-gcc10/hydra-oracle-sid.c
--- hydra-8.6/hydra-oracle-sid.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-oracle-sid.c	2021-10-17 23:50:04.730877987 +0200
@@ -19,7 +19,6 @@
 #define HASHSIZE 16
 
 extern char *HYDRA_EXIT;
-char *buf;
 unsigned char *hash;
 
 
@@ -40,6 +39,7 @@
   char connect_string[200];
   char buffer2[260];
   int32_t siz = 0;
+  char *buf;
 
   memset(connect_string, 0, sizeof(connect_string));
   memset(buffer2, 0, sizeof(buffer2));
diff -ur hydra-8.6/hydra-pcnfs.c hydra-8.6-gcc10/hydra-pcnfs.c
--- hydra-8.6/hydra-pcnfs.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-pcnfs.c	2021-10-17 23:50:04.730877987 +0200
@@ -3,7 +3,6 @@
 /* pcnfs stuff copied from prout.c */
 
 extern char *HYDRA_EXIT;
-char *buf;
 
 #define LEN_HDR_RPC	24
 #define LEN_AUTH_UNIX   72+12
@@ -37,6 +36,7 @@
   char *empty = "";
   char *login, *pass, buffer[LEN_HDR_RPC + LEN_AUTH_UNIX + LEN_HDR_PCN_AUTH];
   char *ptr, *pkt = buffer;
+  char *buf;
 
   unsigned long *authp;
   struct timeval tv;
diff -ur hydra-8.6/hydra-pop3.c hydra-8.6-gcc10/hydra-pop3.c
--- hydra-8.6/hydra-pop3.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-pop3.c	2021-10-17 23:50:04.730877987 +0200
@@ -13,7 +13,6 @@
 } pool;
 
 extern char *HYDRA_EXIT;
-char *buf;
 char apop_challenge[300] = "";
 pool *plist = NULL, *p = NULL;
 
@@ -120,6 +119,7 @@
 int32_t start_pop3(int32_t s, char *ip, int32_t port, unsigned char options, char *miscptr, FILE * fp) {
   char *empty = "\"\"";
   char *login, *pass, buffer[500], buffer2[500], *fooptr;
+  char *buf;
 
   if (strlen(login = hydra_get_next_login()) == 0)
     login = empty;
@@ -416,6 +416,7 @@
 void service_pop3(char *ip, int32_t sp, unsigned char options, char *miscptr, FILE * fp, int32_t port, char *hostname) {
   int32_t run = 1, next_run = 1, sock = -1;
   char *ptr = NULL;
+  char *buf;
 
   //extract data from the pool, ip is the key
   if (plist == NULL)
@@ -520,6 +521,7 @@
   char *capa_str = "CAPA\r\n";
   char *quit_str = "QUIT\r\n";
   pool p;
+  char *buf;
 
   p.pop3_auth_mechanism = AUTH_CLEAR;
   p.disable_tls = 1;
diff -ur hydra-8.6/hydra-redis.c hydra-8.6-gcc10/hydra-redis.c
--- hydra-8.6/hydra-redis.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-redis.c	2021-10-17 23:50:04.730877987 +0200
@@ -1,11 +1,11 @@
 #include "hydra-mod.h"
 
 extern char *HYDRA_EXIT;
-char *buf;
 
 int32_t start_redis(int32_t s, char *ip, int32_t port, unsigned char options, char *miscptr, FILE * fp) {
   char *pass, buffer[510];
   char *empty = "";
+  char *buf;
 
   if (strlen(pass = hydra_get_next_password()) == 0)
     pass = empty;
@@ -133,6 +133,7 @@
   int32_t sock = -1;
   int32_t myport = PORT_REDIS, mysslport = PORT_REDIS_SSL;
   char buffer[] = "*1\r\n$4\r\nping\r\n";
+  char *buf;
 
   hydra_register_socket(sp);
   if ((options & OPTION_SSL) == 0) {
diff -ur hydra-8.6/hydra-rexec.c hydra-8.6-gcc10/hydra-rexec.c
--- hydra-8.6/hydra-rexec.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-rexec.c	2021-10-17 23:50:04.730877987 +0200
@@ -5,7 +5,6 @@
 #define COMMAND "/bin/ls /"
 
 extern char *HYDRA_EXIT;
-char *buf;
 
 int32_t start_rexec(int32_t s, char *ip, int32_t port, unsigned char options, char *miscptr, FILE * fp) {
   char *empty = "";
diff -ur hydra-8.6/hydra-rlogin.c hydra-8.6-gcc10/hydra-rlogin.c
--- hydra-8.6/hydra-rlogin.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-rlogin.c	2021-10-17 23:50:04.730877987 +0200
@@ -12,7 +12,6 @@
 #define TERM "vt100/9600"
 
 extern char *HYDRA_EXIT;
-char *buf;
 
 int32_t start_rlogin(int32_t s, char *ip, int32_t port, unsigned char options, char *miscptr, FILE * fp) {
   char *empty = "";
diff -ur hydra-8.6/hydra-rpcap.c hydra-8.6-gcc10/hydra-rpcap.c
--- hydra-8.6/hydra-rpcap.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-rpcap.c	2021-10-17 23:50:04.730877987 +0200
@@ -4,11 +4,11 @@
 #include "hydra-mod.h"
 
 extern char *HYDRA_EXIT;
-char *buf;
 
 int32_t start_rpcap(int32_t s, char *ip, int32_t port, unsigned char options, char *miscptr, FILE * fp) {
   char *empty = "";
   char *login, *pass, buffer[1024];
+  char *buf;
 
   if (strlen(login = hydra_get_next_login()) == 0)
     login = empty;
@@ -128,6 +128,7 @@
   int32_t sock = -1;
   int32_t myport = PORT_RPCAP, mysslport = PORT_RPCAP_SSL;
   char buffer[] = "\x00\x08\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x00";
+  char *buf;
 
   hydra_register_socket(sp);
   if ((options & OPTION_SSL) == 0) {
diff -ur hydra-8.6/hydra-rsh.c hydra-8.6-gcc10/hydra-rsh.c
--- hydra-8.6/hydra-rsh.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-rsh.c	2021-10-17 23:50:04.730877987 +0200
@@ -11,7 +11,6 @@
 */
 
 extern char *HYDRA_EXIT;
-char *buf;
 
 int32_t start_rsh(int32_t s, char *ip, int32_t port, unsigned char options, char *miscptr, FILE * fp) {
   char *empty = "";
diff -ur hydra-8.6/hydra-rtsp.c hydra-8.6-gcc10/hydra-rtsp.c
--- hydra-8.6/hydra-rtsp.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-rtsp.c	2021-10-17 23:50:04.730877987 +0200
@@ -12,7 +12,6 @@
 #include "sasl.h"
 
 extern char *HYDRA_EXIT;
-char *buf;
 char packet[500];
 char packet2[500];
 
diff -ur hydra-8.6/hydra-smtp-enum.c hydra-8.6-gcc10/hydra-smtp-enum.c
--- hydra-8.6/hydra-smtp-enum.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-smtp-enum.c	2021-10-17 23:50:04.730877987 +0200
@@ -14,7 +14,6 @@
 #include "hydra-mod.h"
 
 extern char *HYDRA_EXIT;
-char *buf;
 char *err = NULL;
 int32_t tosent = 0;
 
@@ -27,6 +26,7 @@
 int32_t start_smtp_enum(int32_t s, char *ip, int32_t port, unsigned char options, char *miscptr, FILE * fp) {
   char *empty = "";
   char *login, *pass, buffer[500];
+  char *buf;
 
   if (strlen(login = hydra_get_next_login()) == 0)
     login = empty;
@@ -154,6 +154,7 @@
   int32_t run = 1, next_run = 1, sock = -1, i = 0;
   int32_t myport = PORT_SMTP, mysslport = PORT_SMTP_SSL;
   char *buffer = "HELO hydra\r\n";
+  char *buf;
 
   hydra_register_socket(sp);
   if (memcmp(hydra_get_next_pair(), &HYDRA_EXIT, sizeof(HYDRA_EXIT)) == 0)
diff -ur hydra-8.6/hydra-socks5.c hydra-8.6-gcc10/hydra-socks5.c
--- hydra-8.6/hydra-socks5.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-socks5.c	2021-10-17 23:50:04.730877987 +0200
@@ -10,7 +10,6 @@
 */
 
 extern char *HYDRA_EXIT;
-unsigned char *buf;
 
 int32_t fail_cnt;
 
@@ -18,6 +17,7 @@
   char *empty = "";
   char *login, *pass, buffer[300];
   int32_t pport, fud = 0;
+  unsigned char *buf;
 
   if (strlen(login = hydra_get_next_login()) == 0)
     login = empty;
diff -ur hydra-8.6/hydra-teamspeak.c hydra-8.6-gcc10/hydra-teamspeak.c
--- hydra-8.6/hydra-teamspeak.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-teamspeak.c	2021-10-17 23:50:04.730877987 +0200
@@ -36,7 +36,6 @@
 extern int32_t hydra_data_ready_timed(int32_t socket, long sec, long usec);
 
 extern char *HYDRA_EXIT;
-char *buf;
 
 int32_t start_teamspeak(int32_t s, char *ip, int32_t port, unsigned char options, char *miscptr, FILE * fp) {
   char *empty = "";
diff -ur hydra-8.6/hydra-telnet.c hydra-8.6-gcc10/hydra-telnet.c
--- hydra-8.6/hydra-telnet.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-telnet.c	2021-10-17 23:50:04.730877987 +0200
@@ -2,13 +2,13 @@
 #include <arpa/telnet.h>
 
 extern char *HYDRA_EXIT;
-char *buf;
 int32_t no_line_mode;
 
 int32_t start_telnet(int32_t s, char *ip, int32_t port, unsigned char options, char *miscptr, FILE * fp) {
   char *empty = "";
   char *login, *pass, buffer[300];
   int32_t i = 0;
+  char *buf;
 
   if (strlen(login = hydra_get_next_login()) == 0)
     login = empty;
@@ -99,6 +99,7 @@
 void service_telnet(char *ip, int32_t sp, unsigned char options, char *miscptr, FILE * fp, int32_t port, char *hostname) {
   int32_t run = 1, next_run = 1, sock = -1, fck;
   int32_t myport = PORT_TELNET, mysslport = PORT_TELNET_SSL;
+  char *buf;
 
   hydra_register_socket(sp);
   if (memcmp(hydra_get_next_pair(), &HYDRA_EXIT, sizeof(HYDRA_EXIT)) == 0)
diff -ur hydra-8.6/hydra-vmauthd.c hydra-8.6-gcc10/hydra-vmauthd.c
--- hydra-8.6/hydra-vmauthd.c	2017-07-21 13:26:40.000000000 +0200
+++ hydra-8.6-gcc10/hydra-vmauthd.c	2021-10-17 23:50:04.730877987 +0200
@@ -8,11 +8,11 @@
 
 extern char *HYDRA_EXIT;
 
-char *buf;
 
 int32_t start_vmauthd(int32_t s, char *ip, int32_t port, unsigned char options, char *miscptr, FILE * fp) {
   char *empty = "\"\"";
   char *login, *pass, buffer[300];
+  char *buf;
 
   if (strlen(login = hydra_get_next_login()) == 0)
     login = empty;
@@ -68,6 +68,7 @@
 void service_vmauthd(char *ip, int32_t sp, unsigned char options, char *miscptr, FILE * fp, int32_t port, char *hostname) {
   int32_t run = 1, next_run = 1, sock = -1;
   int32_t myport = PORT_VMAUTHD, mysslport = PORT_VMAUTHD_SSL;
+  char *buf;
 
   hydra_register_socket(sp);
   if (memcmp(hydra_get_next_pair(), &HYDRA_EXIT, sizeof(HYDRA_EXIT)) == 0)
